WHITESPACE: /\s/
%ignore WHITESPACE
_NEWLINE: /(\n|\r|\r\n)+/

COMMENT: /#.*/
%ignore COMMENT

INT_LITERAL.2: /\-?\d+/
FLOAT_LITERAL: /\-?\d*\.\d+([eE][+-]?\d+)?/
IDENTIFIER: /(?!noop)(?!else)(?!return)[a-z_][a-z_\d]*/
PATTERN: /([-WYORGBa-z]+\/)+[-WYORGBa-z]+/

_elif_clause: "else-if" expression "then" clause
if_expression: "if" expression "then" clause (_elif_clause)* ("else" clause)? "end"
while_expression: "while" expression "do" clause "end"
do_expression: "do" clause "while" expression
repeat_expression: "repeat" expression "times" clause "end"
for_expression: "for" IDENTIFIER "in" expression "do" clause "end"

ORIENT_PARAM_NAME: "front" | "back" | "left" | "right" | "top" | "bottom" | "keeping"
orient_params: ORIENT_PARAM_NAME ":" expression ("," ORIENT_PARAM_NAME ":" expression)*
_else_orient: "else-orient" orient_params " then" clause
orient_expression: "orient" orient_params "then" clause (_else_orient)* ("else" clause)? "end" -> if_expression

collection_item: op_item "[" expression "]"
cube_color_reference: op_item "[" expression "," expression "]"

?op_if: if_expression | op_item
?op_item: atom | collection_item | cube_color_reference

?atom: INT_LITERAL -> int_literal
           | FLOAT_LITERAL -> float_literal
           | IDENTIFIER -> variable
           | PATTERN -> pattern
           | "(" expression ")"
           | "-" expression -> negation
           | IDENTIFIER "(" (expression ",")* expression? ")" -> func_call

?expression: op_0

?assignable: IDENTIFIER | collection_item

pattern: "(" PATTERN ")"

?type: "int" -> type_int
     | "real" -> type_real
     | "boolean" -> type_bool
     | "side" -> type_side
     | "color" -> type_color
     | "pattern" -> type_pattern
     | "list" "of" type -> type_list
     | "set" "of" type -> type_set

var_decl: "let" (IDENTIFIER ",")* IDENTIFIER ":" type ("=" expression)?
argument: IDENTIFIER ":" type ("=" expression)?
func_decl: "func" IDENTIFIER "(" (argument ",")* argument? ")" (":" type)? clause "end"
return_statement: "return" expression?
var_assignment: assignable "=" expression

?cube_command: "R" -> cube_right
            | "L" -> cube_left
            | "U" -> cube_top
            | "D" -> cube_bottom
            | "F" -> cube_front
            | "B" -> cube_back
            | "X" -> cube_rotate_right
            | "Y" -> cube_rotate_top
            | "Z" -> cube_rotate_front
?cube_action: cube_command
            | cube_command "2" -> cube_double
            | cube_command "'" -> cube_opposite
cube_instruction: cube_action+

?statement: var_decl | expression | var_assignment | while_expression
          | func_decl | return_statement | do_expression | repeat_expression
          | for_expression | cube_instruction | orient_expression | "noop" -> noop_expression
clause: (statement _NEWLINE)* statement?
