WHITESPACE: /\s/
%ignore WHITESPACE
_NEWLINE: /(\n|\r|\r\n)+/

INT_LITERAL.2: /\-?\d+/
FLOAT_LITERAL: /\-?\d*\.\d+([eE][+-]?\d+)?/
IDENTIFIER: /[a-zA-Z_][a-zA-Z_\d]*/

if_expression: "if" expression "then" clause ("else" clause)? "end"
while_expression: "while" expression "do" clause "end"
do_expression: "do" clause "while" expression
repeat_expression: "repeat" expression "times" clause "end"
for_expression: "for" IDENTIFIER "in" expression "do" clause "end"

?op_a.7: if_expression | op_0
?atom: INT_LITERAL -> int_literal
           | FLOAT_LITERAL -> float_literal
           | IDENTIFIER -> variable
           | collection_item
           | "(" expression ")" 
           | "-" expression -> negation
           | IDENTIFIER "(" (expression ",")* expression ")" -> func_call

?expression: op_a

collection_item: IDENTIFIER "[" expression "]"
?assignable: IDENTIFIER | collection_item

?type: "int" -> type_int
     | "real" -> type_real
     | "boolean" -> type_bool
     | "side" -> type_side
     | "color" -> type_color
     | "list" "of" type -> type_list
     | "set" "of" type -> type_set

var_decl: "let" (IDENTIFIER ",")* IDENTIFIER ":" type ("=" expression)?
argument: IDENTIFIER ":" type ("=" expression)?
func_decl: "func" IDENTIFIER "(" (argument ",")* argument? ")" (":" type)? clause*
var_assignment: assignable "=" expression

?statement: var_decl | func_decl | expression | var_assignment | while_expression 
          | do_expression | repeat_expression | for_expression
clause: (statement _NEWLINE)* statement?
