WHITESPACE: /\s/
%ignore WHITESPACE
_NEWLINE: /(\n|\r|\r\n)+/

INT_LITERAL.2: /\-?\d+/
FLOAT_LITERAL: /\-?\d*\.\d+([eE][+-]?\d+)?/
IDENTIFIER: /[a-zA-Z_][a-zA-Z_\d]*/

?op_sum.2: op_mul
         | op_sum "+" op_mul -> op_add
         | op_sum "-" op_mul -> op_subtract

?op_mul.1: atom
         | op_mul "*" atom -> op_multiply
         | op_mul "/" atom -> op_divide

if_expression: "if" expression "then" _clause ("else" _clause)?
while_expression: "while" expression "do" _clause
do_expression: "do" _clause "while" expression
repeat_expression: "repeat" expression "times" _clause
for_expression: "for" IDENTIFIER "in" expression "do" _clause

?atom: INT_LITERAL -> int_literal
           | FLOAT_LITERAL -> float_literal
           | IDENTIFIER -> variable
           | collection_item
           | "(" expression ")" 
           | "-" expression -> negation
           | IDENTIFIER "(" (expression ",")* expression ")" -> func_call
           | if_expression
           | while_expression
           | do_expression
           | repeat_expression
           | for_expression

?expression: op_sum

collection_item: IDENTIFIER "[" expression "]"
?assignable: IDENTIFIER | collection_item

?type: "int" -> type_int
     | "real" -> type_real
     | "boolean" -> type_bool
     | "list" "of" type -> type_list
     | "set" "of" type -> type_set

var_decl: "let" (IDENTIFIER ",")* IDENTIFIER ":" type ("=" expression)?
argument: IDENTIFIER ":" type ("=" expression)?
func_decl: "func" IDENTIFIER "(" (argument ",")* argument? ")" (":" type)? _clause
var_assignment: assignable "=" expression

?statement: var_decl | func_decl | expression | var_assignment
_clause: statement | "{" start "}"
?start: (_clause _NEWLINE)* _clause?
